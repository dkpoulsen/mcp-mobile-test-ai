# GitHub Actions workflow to build and test using Docker Compose
# This workflow orchestrates all services (app, database, cache) defined in docker-compose.yml

name: Docker Compose CI

on:
  push:
    branches: [main, master, develop]
  pull_request:
    branches: [main, master, develop]
  workflow_dispatch:

env:
  NODE_VERSION: "20"
  POSTGRES_USER: mcpmobile
  POSTGRES_PASSWORD: mcpmobilepass
  POSTGRES_DB: mcpmobiletest
  POSTGRES_PORT: 5432
  REDIS_PORT: 6379
  API_PORT: 3000
  LLM_PROVIDER: mock
  LLM_MODEL: gpt-4
  LOG_LEVEL: error

jobs:
  # Main Docker Compose job that builds and tests all services
  docker-compose-test:
    name: Docker Compose Test
    runs-on: ubuntu-latest
    timeout-minutes: 30
    outputs:
      test-result: ${{ steps.test.outcome }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # Cache Docker layers to speed up builds
      - name: Cache Docker layers
        uses: actions/cache@v4
        with:
          path: /tmp/.buildx-cache
          key: ${{ runner.os }}-buildx-${{ github.sha }}
          restore-keys: |
            ${{ runner.os }}-buildx-

      # Copy environment template and inject GitHub Secrets
      - name: Create environment file
        run: |
          if [ -f .env.example ]; then
            cp .env.example .env
          fi

          # Inject or override with GitHub Secrets if available
          if [ -n "${{ secrets.LLM_API_KEY }}" ]; then
            echo "LLM_API_KEY=${{ secrets.LLM_API_KEY }}" >> .env
          else
            echo "LLM_API_KEY=test-mock-key" >> .env
          fi

          # Set required environment variables
          echo "NODE_ENV=test" >> .env
          echo "POSTGRES_USER=${{ env.POSTGRES_USER }}" >> .env
          echo "POSTGRES_PASSWORD=${{ env.POSTGRES_PASSWORD }}" >> .env
          echo "POSTGRES_DB=${{ env.POSTGRES_DB }}" >> .env
          echo "POSTGRES_PORT=${{ env.POSTGRES_PORT }}" >> .env
          echo "REDIS_PORT=${{ env.REDIS_PORT }}" >> .env
          echo "LLM_PROVIDER=${{ env.LLM_PROVIDER }}" >> .env
          echo "LLM_MODEL=${{ env.LLM_MODEL }}" >> .env
          echo "LOG_LEVEL=${{ env.LOG_LEVEL }}" >> .env

      # Build Docker images with parallel flag
      - name: Build Docker Compose images
        run: |
          docker compose build --parallel
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          LLM_PROVIDER: ${{ env.LLM_PROVIDER }}
          LLM_API_KEY: test-mock-key

      # Start services in detached mode
      - name: Start Docker Compose services
        run: |
          docker compose up -d
        env:
          POSTGRES_USER: ${{ env.POSTGRES_USER }}
          POSTGRES_PASSWORD: ${{ env.POSTGRES_PASSWORD }}
          POSTGRES_DB: ${{ env.POSTGRES_DB }}
          LLM_PROVIDER: ${{ env.LLM_PROVIDER }}
          LLM_API_KEY: test-mock-key

      # Wait for services to be healthy with retries
      - name: Health check - PostgreSQL
        run: |
          echo "Waiting for PostgreSQL to be ready..."
          for i in {1..30}; do
            if docker exec mcp-mobile-test-postgres pg_isready -U ${{ env.POSTGRES_USER }} > /dev/null 2>&1; then
              echo "PostgreSQL is ready!"
              exit 0
            fi
            echo "Attempt $i/30: PostgreSQL not ready yet..."
            sleep 2
          done
          echo "PostgreSQL health check failed after 30 attempts"
          exit 1

      - name: Health check - Redis
        run: |
          echo "Waiting for Redis to be ready..."
          for i in {1..30}; do
            if docker exec mcp-mobile-test-redis redis-cli ping > /dev/null 2>&1; then
              echo "Redis is ready!"
              exit 0
            fi
            echo "Attempt $i/30: Redis not ready yet..."
            sleep 2
          done
          echo "Redis health check failed after 30 attempts"
          exit 1

      - name: Display running containers
        run: |
          echo "Running containers:"
          docker compose ps
          echo ""
          echo "Container logs:"
          docker compose logs

      # Run tests using docker-compose exec
      - name: Run tests
        id: test
        run: |
          docker compose exec -T test npm test
        env:
          NODE_ENV: test
          LLM_PROVIDER: mock
          LLM_API_KEY: test-mock-key
        continue-on-error: false

      # Collect test results and coverage reports
      - name: Collect test results
        if: always()
        run: |
          # Create test results directory
          mkdir -p test-results
          mkdir -p coverage

          # Copy test results from container if they exist
          docker cp mcp-mobile-test-runner:/app/test-reports ./test-results/ || true
          docker cp mcp-mobile-test-runner:/app/coverage ./coverage/ || true
          docker cp mcp-mobile-test-runner:/app/logs ./logs/ || true

      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose-test-results
          path: |
            test-results/
            coverage/
            logs/
          retention-days: 7

      # Collect logs on failure for debugging
      - name: Collect logs on failure
        if: failure()
        run: |
          mkdir -p docker-logs
          docker compose logs --no-color > docker-logs/docker-compose.log
          docker compose ps > docker-logs/containers-status.log

          # Collect individual service logs
          docker logs mcp-mobile-test-postgres --no-color > docker-logs/postgres.log 2>&1 || true
          docker logs mcp-mobile-test-redis --no-color > docker-logs/redis.log 2>&1 || true
          docker logs mcp-mobile-test-runner --no-color > docker-logs/test-runner.log 2>&1 || true

      - name: Upload logs on failure
        if: failure()
        uses: actions/upload-artifact@v4
        with:
          name: docker-compose-failure-logs
          path: docker-logs/
          retention-days: 7

      # Cleanup - stop services and remove volumes
      - name: Cleanup Docker Compose
        if: always()
        run: |
          docker compose down -v

  # Optional matrix job for testing multiple Docker Compose configurations
  docker-compose-matrix:
    name: Docker Compose (${{ matrix.compose-file }})
    runs-on: ubuntu-latest
    timeout-minutes: 30
    strategy:
      fail-fast: false
      matrix:
        compose-file:
          - docker-compose.yml
          - docker-compose.test.yml
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Create environment file
        run: |
          if [ -f .env.example ]; then
            cp .env.example .env
          fi
          echo "NODE_ENV=test" >> .env
          echo "LLM_PROVIDER=mock" >> .env
          echo "LLM_API_KEY=test-mock-key" >> .env
          echo "POSTGRES_USER=mcpmobile" >> .env
          echo "POSTGRES_PASSWORD=mcpmobilepass" >> .env
          echo "POSTGRES_DB=mcpmobiletest_test" >> .env
          echo "LOG_LEVEL=error" >> .env

      - name: Build Docker images
        run: |
          docker compose -f ${{ matrix.compose-file }} build --parallel

      - name: Start services
        run: |
          docker compose -f ${{ matrix.compose-file }} up -d

      - name: Wait for services
        run: |
          sleep 10
          docker compose -f ${{ matrix.compose-file }} ps

      - name: Run tests
        run: |
          # For docker-compose.test.yml, tests run automatically
          # For docker-compose.yml, we need to exec into the test container
          if [ "${{ matrix.compose-file }}" == "docker-compose.yml" ]; then
            docker compose exec -T test npm test || docker compose logs
          else
            docker compose -f ${{ matrix.compose-file }} logs --tail 50
          fi

      - name: Upload logs on failure
        if: failure()
        run: |
          docker compose -f ${{ matrix.compose-file }} logs --no-color > matrix-${{ matrix.compose-file }}.log
        continue-on-error: true

      - name: Cleanup
        if: always()
        run: |
          docker compose -f ${{ matrix.compose-file }} down -v

  # Security scanning with Trivy
  security-scan:
    name: Security Scan (Trivy)
    runs-on: ubuntu-latest
    timeout-minutes: 15
    needs: docker-compose-test
    permissions:
      contents: read
      security-events: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for scanning
        run: |
          docker build -f Dockerfile.test -t mcp-mobile-test:test .

      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@0.24.0
        with:
          image-ref: mcp-mobile-test:test
          format: 'sarif'
          output: 'trivy-results.sarif'
          severity: 'CRITICAL,HIGH'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

  # Final status check
  status-check:
    name: Docker Compose CI Status
    runs-on: ubuntu-latest
    needs: [docker-compose-test, docker-compose-matrix, security-scan]
    if: always()
    steps:
      - name: Check all job results
        run: |
          if [[ "${{ needs.docker-compose-test.result }}" == "failure" ]] || \
             [[ "${{ needs.docker-compose-test.result }}" == "cancelled" ]]; then
            echo "::error::Main Docker Compose test job failed or was cancelled"
            exit 1
          fi

          if [[ "${{ needs.security-scan.result }}" == "failure" ]]; then
            echo "::warning::Security scan found critical vulnerabilities"
          fi

          echo "Docker Compose CI completed successfully"
