/**
 * Selenium Converter Service
 * Main service for converting Selenium tests from Java/Python to TypeScript
 */

import { readFileSync, existsSync, mkdirSync, writeFileSync, readdirSync } from 'fs';
import { join, dirname, extname, basename } from 'path';
import type {
  SourceLanguage,
  ConversionOptions,
  ConversionResult,
  ParsedSeleniumTestSuite,
  TargetFramework,
} from './types.js';
import { SeleniumConverterError, ConverterErrorType } from './types.js';
import { createJavaParser } from './java-parser.js';
import { createPythonParser } from './python-parser.js';
import { createCodeGenerator } from './code-generator.js';

/**
 * Default conversion options
 */
const DEFAULT_OPTIONS: Partial<ConversionOptions> = {
  targetFramework: 'playwright',
  outputDir: 'tests/converted',
  generatePageObjects: true,
  useTypeScript: true,
  baseUrl: 'http://localhost:3000',
  includeComments: true,
  preserveStructure: true,
  timeout: {
    implicit: 10000,
    pageLoad: 60000,
    script: 30000,
  },
};

/**
 * Selenium Converter class
 */
export class SeleniumConverter {
  /**
   * Convert a single file
   */
  async convertFile(
    filePath: string,
    options: ConversionOptions
  ): Promise<ConversionResult> {
    const startTime = Date.now();
    const warnings: string[] = [];
    const errors: string[] = [];

    try {
      // Validate input
      if (!existsSync(filePath)) {
        throw new SeleniumConverterError(
          ConverterErrorType.FILE_NOT_FOUND,
          `File not found: ${filePath}`
        );
      }

      // Read file content
      const content = readFileSync(filePath, 'utf-8');

      // Detect source language from extension
      const sourceLanguage = this.detectSourceLanguage(filePath);

      // Parse the file
      const testSuite = this.parseFile(content, filePath, sourceLanguage);

      // Merge options with defaults
      const opts = this.mergeOptions(options);

      // Ensure output directory exists
      this.ensureDirectory(opts.outputDir);

      // Generate code
      const generator = createCodeGenerator();
      const files = generator.generateTestSuite(testSuite, opts);

      // Write files to disk
      for (const file of files) {
        const outputPath = join(process.cwd(), file.filePath);
        this.ensureDirectory(dirname(outputPath));

        if (opts.includeComments) {
          // Add conversion notice at the top
          const notice = `/**
 * Auto-converted from ${basename(filePath)}
 * Generated by Selenium Converter
 */
`;
          writeFileSync(outputPath, notice + file.content, 'utf-8');
        } else {
          writeFileSync(outputPath, file.content, 'utf-8');
        }
      }

      const processingTimeMs = Date.now() - startTime;

      return {
        success: true,
        files,
        warnings,
        errors,
        summary: {
          sourceFiles: 1,
          testCasesConverted: testSuite.testCases.length,
          pageObjectsGenerated: files.filter(f => f.fileType === 'page-object').length,
          actionsConverted: testSuite.testCases.reduce((sum, tc) => sum + tc.steps.length, 0),
          unsupportedActions: 0,
          processingTimeMs,
        },
      };
    } catch (error) {
      if (error instanceof SeleniumConverterError) {
        throw error;
      }

      errors.push(error instanceof Error ? error.message : String(error));

      return {
        success: false,
        files: [],
        warnings,
        errors,
        summary: {
          sourceFiles: 1,
          testCasesConverted: 0,
          pageObjectsGenerated: 0,
          actionsConverted: 0,
          unsupportedActions: 0,
          processingTimeMs: Date.now() - startTime,
        },
      };
    }
  }

  /**
   * Convert a directory of test files
   */
  async convertDirectory(
    dirPath: string,
    options: ConversionOptions
  ): Promise<ConversionResult> {
    const startTime = Date.now();
    const allFiles: GeneratedFile[] = [];
    const allWarnings: string[] = [];
    const allErrors: string[] = [];

    let totalTestCases = 0;
    let totalPageObjects = 0;
    let totalActions = 0;
    let unsupportedActions = 0;

    try {
      if (!existsSync(dirPath)) {
        throw new SeleniumConverterError(
          ConverterErrorType.FILE_NOT_FOUND,
          `Directory not found: ${dirPath}`
        );
      }

      // Recursively find test files
      const testFiles = this.findTestFiles(dirPath);

      if (testFiles.length === 0) {
        allWarnings.push(`No test files found in ${dirPath}`);
        return {
          success: true,
          files: [],
          warnings: allWarnings,
          errors: allErrors,
          summary: {
            sourceFiles: 0,
            testCasesConverted: 0,
            pageObjectsGenerated: 0,
            actionsConverted: 0,
            unsupportedActions: 0,
            processingTimeMs: Date.now() - startTime,
          },
        };
      }

      // Convert each file
      for (const testFile of testFiles) {
        try {
          const result = await this.convertFile(testFile, options);

          allFiles.push(...result.files);
          allWarnings.push(...result.warnings);
          allErrors.push(...result.errors);

          totalTestCases += result.summary.testCasesConverted;
          totalPageObjects += result.summary.pageObjectsGenerated;
          totalActions += result.summary.actionsConverted;
          unsupportedActions += result.summary.unsupportedActions;
        } catch (error) {
          allErrors.push(`Failed to convert ${testFile}: ${error instanceof Error ? error.message : String(error)}`);
        }
      }

      return {
        success: allErrors.length === 0,
        files: allFiles,
        warnings: allWarnings,
        errors: allErrors,
        summary: {
          sourceFiles: testFiles.length,
          testCasesConverted: totalTestCases,
          pageObjectsGenerated: totalPageObjects,
          actionsConverted: totalActions,
          unsupportedActions,
          processingTimeMs: Date.now() - startTime,
        },
      };
    } catch (error) {
      if (error instanceof SeleniumConverterError) {
        throw error;
      }

      throw new SeleniumConverterError(
        ConverterErrorType.UNKNOWN,
        'Failed to convert directory',
        error
      );
    }
  }

  /**
   * Detect source language from file extension
   */
  private detectSourceLanguage(filePath: string): SourceLanguage {
    const ext = extname(filePath).toLowerCase();

    if (ext === '.java') {
      return 'java';
    } else if (ext === '.py') {
      return 'python';
    }

    throw new SeleniumConverterError(
      ConverterErrorType.UNSUPPORTED,
      `Unsupported file extension: ${ext}. Only .java and .py files are supported.`
    );
  }

  /**
   * Parse file based on source language
   */
  private parseFile(
    content: string,
    filePath: string,
    sourceLanguage: SourceLanguage
  ): ParsedSeleniumTestSuite {
    switch (sourceLanguage) {
      case 'java':
        const javaParser = createJavaParser();
        return javaParser.parseFile(content, filePath);

      case 'python':
        const pythonParser = createPythonParser();
        return pythonParser.parseFile(content, filePath);

      default:
        throw new SeleniumConverterError(
          ConverterErrorType.UNSUPPORTED,
          `Unsupported source language: ${sourceLanguage}`
        );
    }
  }

  /**
   * Merge user options with defaults
   */
  private mergeOptions(options: ConversionOptions): Required<ConversionOptions> {
    return {
      targetFramework: options.targetFramework || DEFAULT_OPTIONS.targetFramework!,
      outputDir: options.outputDir || DEFAULT_OPTIONS.outputDir!,
      generatePageObjects: options.generatePageObjects ?? DEFAULT_OPTIONS.generatePageObjects!,
      useTypeScript: options.useTypeScript ?? DEFAULT_OPTIONS.useTypeScript!,
      baseUrl: options.baseUrl || DEFAULT_OPTIONS.baseUrl!,
      includeComments: options.includeComments ?? DEFAULT_OPTIONS.includeComments!,
      preserveStructure: options.preserveStructure ?? DEFAULT_OPTIONS.preserveStructure!,
      timeout: {
        ...DEFAULT_OPTIONS.timeout!,
        ...options.timeout,
      },
    };
  }

  /**
   * Ensure directory exists, create if not
   */
  private ensureDirectory(dirPath: string): void {
    if (!existsSync(dirPath)) {
      mkdirSync(dirPath, { recursive: true });
    }
  }

  /**
   * Find all test files in directory recursively
   */
  private findTestFiles(dirPath: string): string[] {
    const testFiles: string[] = [];
    const supportedExtensions = ['.java', '.py'];

    const items = readdirSync(dirPath, { withFileTypes: true });

    for (const item of items) {
      const fullPath = join(dirPath, item.name);

      if (item.isDirectory()) {
        // Recursively search subdirectories
        testFiles.push(...this.findTestFiles(fullPath));
      } else if (item.isFile()) {
        const ext = extname(item.name).toLowerCase();
        if (supportedExtensions.includes(ext)) {
          testFiles.push(fullPath);
        }
      }
    }

    return testFiles;
  }

  /**
   * Get supported source languages
   */
  getSupportedSourceLanguages(): SourceLanguage[] {
    return ['java', 'python'];
  }

  /**
   * Get supported target frameworks
   */
  getSupportedTargetFrameworks(): TargetFramework[] {
    return ['playwright', 'webdriverio', 'appium'];
  }
}

/**
 * Type for generated files
 */
type GeneratedFile = {
  fileName: string;
  filePath: string;
  content: string;
  fileType: 'test' | 'page-object' | 'helper' | 'config';
};

/**
 * Singleton instance management
 */
let converterInstance: SeleniumConverter | undefined;

/**
 * Get or create the converter instance
 */
export function getSeleniumConverter(): SeleniumConverter {
  if (!converterInstance) {
    converterInstance = new SeleniumConverter();
  }
  return converterInstance;
}

/**
 * Reset the converter instance (useful for testing)
 */
export function resetSeleniumConverter(): void {
  converterInstance = undefined;
}
